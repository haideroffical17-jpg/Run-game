<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Endless Runner</title>
  <style>
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    #gameCanvas{display:block;width:100%;height:100vh;}

    /* UI overlays */
    .overlay{position:fixed;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .panel{pointer-events:auto;background:rgba(10,10,20,0.9);color:#fff;padding:24px;border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,0.6);max-width:420px;width:90%;text-align:center}
    .panel h1{margin:0 0 8px;font-size:24px}
    .panel p{margin:8px 0 16px;color:#d0d4dd}
    .btn{display:inline-block;padding:10px 18px;border-radius:10px;background:#0ea5ae;color:#042;cursor:pointer;font-weight:600;border:none}
    .small{font-size:13px;color:#a6b0c8}

    #hud{position:fixed;left:18px;top:18px;color:#fff;font-weight:600;text-shadow:0 2px 4px rgba(0,0,0,0.6)}
    #score{font-size:18px}
    #high{font-size:12px;opacity:0.9}

    #controls{position:fixed;right:18px;bottom:18px;color:#fff;text-align:right;font-size:13px}
    .hint{background:rgba(255,255,255,0.04);padding:6px 8px;border-radius:8px;margin-top:6px}

    /* Mobile on-screen arrows */
    .touch-controls{position:fixed;left:50%;transform:translateX(-50%);bottom:28px;display:flex;gap:10px}
    .tc-btn{width:64px;height:64px;border-radius:16px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700}

    /* Simple instructions for when game ends */
    #gameOverPanel{display:none}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div id="hud">
    <div id="score">Score: 0</div>
    <div id="high">High: 0</div>
  </div>

  <div id="controls">
    <div class="small">Controls: ← → or swipe to change lanes • Space to jump • Down to slide</div>
    <div class="hint">Buses can have ramps — jump or climb them. Stones require jump or slide depending on placement.</div>
  </div>

  <div class="overlay" id="startScreen">
    <div class="panel">
      <h1>3D Runner</h1>
      <p>Three lanes, random buses (some with ramps), stones to jump or slide under. Climb on ramps to change lane height.</p>
      <div style="display:flex;gap:12px;justify-content:center;margin-top:12px">
        <button id="playBtn" class="btn">Play</button>
        <button id="resetHighBtn" class="btn" style="background:#ef4444">Reset High</button>
      </div>
      <p class="small" style="margin-top:12px">High Score: <span id="startHigh">0</span></p>
    </div>
  </div>

  <div class="overlay" id="gameOverPanel" style="display:none;align-items:center;justify-content:center">
    <div class="panel">
      <h1>Game Over</h1>
      <p>Your Score: <strong id="finalScore">0</strong></p>
      <div style="display:flex;gap:12px;justify-content:center;margin-top:12px">
        <button id="restartBtn" class="btn">Play Again</button>
        <button id="menuBtn" class="btn" style="background:#64748b">Menu</button>
      </div>
    </div>
  </div>

  <div class="touch-controls" id="touchControls" style="display:none">
    <div class="tc-btn" id="tcLeft">◀</div>
    <div style="width:8px"></div>
    <div class="tc-btn" id="tcRight">▶</div>
  </div>

  <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
  <script>
  // --- Basic 3D Endless Runner Implementation ---
  // Features implemented:
  // - Three lanes (-2, 0, 2)
  // - Random buses; some buses include a ramp mesh the player can climb
  // - Stones (obstacles) that sometimes require jump and sometimes slide
  // - Jump & Slide mechanics (with simple physics)
  // - Start screen and high score saved in localStorage
  // - Simple collisions using bounding boxes

  (function(){
    // Scene setup
    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x9fb8c6, 0.02);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(0,4,8);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    hemi.position.set(0,20,0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5,10,7);
    scene.add(dir);

    // Ground / road
    const road = new THREE.Mesh(new THREE.PlaneGeometry(30,500,1,1), new THREE.MeshStandardMaterial({color:0x333b45}));
    road.rotation.x = -Math.PI/2;
    road.position.y = 0;
    road.receiveShadow = true;
    scene.add(road);

    // Lane markers
    function makeStripe(yOffset){
      const g = new THREE.PlaneGeometry(0.2, 8);
      const m = new THREE.MeshBasicMaterial({color:0xfffff0});
      const mesh = new THREE.Mesh(g,m);
      mesh.rotation.x = -Math.PI/2;
      mesh.position.y = 0.01;
      return mesh;
    }
    for(let i=0;i<200;i++){
      const stripe = makeStripe();
      stripe.position.z = -i*6 - 6;
      stripe.position.x = 0;
      scene.add(stripe);
    }

    // Player
    const laneX = [-2.2, 0, 2.2];
    const player = new THREE.Mesh(new THREE.BoxGeometry(1,1.8,1.6), new THREE.MeshStandardMaterial({color:0x00aaff}));
    player.position.set(laneX[1], 1.0, 4);
    scene.add(player);

    // Player state
    let currentLane = 1;
    let targetLane = 1;
    let isJumping = false;
    let isSliding = false;
    let verticalVel = 0;
    let slideTimer = 0;

    // Simplified physics parameters
    const GRAVITY = -30;
    const JUMP_V = 12;

    // Obstacles container
    const obstacles = []; // {mesh,type,passed}
    const OBSTACLE_POOL = [];

    // Utility to create bus
    function createBus(withRamp=false){
      const bus = new THREE.Group();
      const body = new THREE.Mesh(new THREE.BoxGeometry(3.6,1.6,6), new THREE.MeshStandardMaterial({color:0xffb86b}));
      body.position.y = 0.9;
      body.position.z = 0;
      bus.add(body);
      // wheels (simple cylinders)
      const wheelGeo = new THREE.CylinderGeometry(0.45,0.45,0.6,12);
      wheelGeo.rotateZ(Math.PI/2);
      for(let x=-1.3;x<=1.3;x+=2.6){
        for(let z=-2.2; z<=2.2; z+=4.4){
          const w = new THREE.Mesh(wheelGeo, new THREE.MeshStandardMaterial({color:0x222}));
          w.position.set(x,0.25,z);
          bus.add(w);
        }
      }
      if(withRamp){
        // ramp top: thin wedge
        const rampGeo = new THREE.BoxGeometry(3.6,0.2,3.2);
        const ramp = new THREE.Mesh(rampGeo,new THREE.MeshStandardMaterial({color:0xd97706}));
        ramp.position.set(0,1.8,0.6);
        ramp.rotation.x = -0.35; // slight slope
        bus.add(ramp);
      }
      return bus;
    }

    function createStone() {
      const geo = new THREE.DodecahedronGeometry(0.7,0);
      const mat = new THREE.MeshStandardMaterial({color:0x6b7280});
      const m = new THREE.Mesh(geo,mat);
      m.position.y = 0.45;
      return m;
    }

    // spawn logic
    let spawnZ = -40;
    function spawnObstacle(){
      // choose type: bus or stone
      const r = Math.random();
      if(r < 0.6){
        // bus
        const lane = Math.floor(Math.random()*3);
        const hasRamp = Math.random() < 0.33; // some buses have ramps
        const bus = createBus(hasRamp);
        bus.position.set(laneX[lane], 0, spawnZ);
        scene.add(bus);
        obstacles.push({mesh:bus, type: hasRamp? 'bus_ramp':'bus', lane, passed:false, hasRamp});
      } else {
        // stone may be placed centered or offset so sometimes player must slide
        const lane = Math.floor(Math.random()*3);
        const stone = createStone();
        // randomly decide if stone is tall (require jump) or low (require slide)
        const tall = Math.random() < 0.5;
        if(!tall){ stone.scale.set(1.8,0.6,1.8); stone.position.y = 0.3; }
        stone.userData.tall = tall;
        stone.position.set(laneX[lane], 0.5, spawnZ);
        scene.add(stone);
        obstacles.push({mesh:stone, type: tall? 'stone_high' : 'stone_low', lane, passed:false});
      }
      spawnZ += -18 - Math.random()*12; // next spawn further
    }

    // prepopulate a few obstacles
    for(let i=0;i<6;i++) spawnObstacle();

    let lastTime = performance.now()/1000;
    let score = 0;
    let speed = 16; // forward world speed
    const speedInc = 0.004;
    let running = false;
    let gameOver = false;

    // HUD elements
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const startHigh = document.getElementById('startHigh');
    const startScreen = document.getElementById('startScreen');
    const gameOverPanel = document.getElementById('gameOverPanel');
    const finalScore = document.getElementById('finalScore');

    // localStorage high score
    function getHigh(){return parseInt(localStorage.getItem('runner_high')||'0',10)}
    function setHigh(v){localStorage.setItem('runner_high',String(v))}
    function refreshHighDisplays(){highEl.textContent = 'High: '+getHigh(); startHigh.textContent = getHigh();}
    refreshHighDisplays();

    // collision helpers
    const playerBox = new THREE.Box3();
    const tmpBox = new THREE.Box3();

    function update(dt){
      if(!running) return;
      // move obstacles forward (increase z) relative to camera/player
      const move = speed * dt;
      for(let i=0;i<obstacles.length;i++){
        const ob = obstacles[i];
        ob.mesh.position.z += move;
        // if passed player far behind, remove
        if(ob.mesh.position.z > 12){
          scene.remove(ob.mesh);
          obstacles.splice(i,1); i--; score += 10; continue;
        }
      }

      // spawn more if necessary
      while(obstacles.length < 8) spawnObstacle();

      // player lane lerp
      const desiredX = laneX[targetLane];
      player.position.x += (desiredX - player.position.x) * Math.min(1, 12*dt);

      // jumping physics
      if(isJumping){
        verticalVel += GRAVITY * dt;
        player.position.y += verticalVel * dt;
        if(player.position.y <= 1.0){
          player.position.y = 1.0; isJumping = false; verticalVel = 0;
        }
      }

      // sliding timer
      if(isSliding){
        slideTimer -= dt;
        // lower player height while sliding
        player.scale.y = 0.6;
        player.position.y = 0.5;
        if(slideTimer <= 0){ isSliding = false; player.scale.y = 1; player.position.y = 1.0; }
      }

      // collisions: simple AABB tests
      playerBox.setFromObject(player);
      for(const ob of obstacles){
        tmpBox.setFromObject(ob.mesh);
        if(playerBox.intersectsBox(tmpBox) && !ob.passed){
          // Determine type and whether player is safe
          if(ob.type === 'bus' || ob.type==='bus_ramp'){
            if(ob.hasRamp){
              // if player is jumping and slightly above ramp, allow climbing: if player.y > 1.6
              if(player.position.y > 1.6){
                // allow: push player forward slightly (simulate climb)
                // but if colliding too low -> game over
                ob.passed = true; continue;
              } else {
                endGame(); return;
              }
            } else {
              endGame(); return;
            }
          } else if(ob.type === 'stone_high'){
            // stone_high needs jump
            if(player.position.y > 1.6){ ob.passed = true; continue; } else { endGame(); return; }
          } else if(ob.type === 'stone_low'){
            // needs slide
            if(isSliding){ ob.passed = true; continue; } else { endGame(); return; }
          }
        }
      }

      // advance score by time
      score += speed * dt * 0.3;
      scoreEl.textContent = 'Score: '+Math.floor(score);
      // slowly increase difficulty
      speed += speedInc * dt * 100;
    }

    function endGame(){
      running = false; gameOver = true;
      finalScore.textContent = Math.floor(score);
      const h = getHigh();
      if(score > h){ setHigh(Math.floor(score)); }
      refreshHighDisplays();
      gameOverPanel.style.display = 'flex';
    }

    function restart(){
      // cleanup obstacles
      for(const ob of obstacles) scene.remove(ob.mesh);
      obstacles.length = 0; spawnZ = -40;
      for(let i=0;i<6;i++) spawnObstacle();
      // reset player
      player.position.set(laneX[1],1.0,4); player.scale.set(1,1,1);
      currentLane = targetLane = 1; isJumping = false; isSliding = false; verticalVel = 0; slideTimer = 0;
      score = 0; speed = 16; gameOver = false; running = true;
      gameOverPanel.style.display = 'none'; startScreen.style.display = 'none';
    }

    // input handling
    window.addEventListener('keydown', (e)=>{
      if(!running) return;
      if(e.key === 'ArrowLeft') moveLeft();
      if(e.key === 'ArrowRight') moveRight();
      if(e.key === ' ' || e.code === 'Space') doJump();
      if(e.key === 'ArrowDown') doSlide();
    });

    function moveLeft(){ if(targetLane>0) targetLane--; }
    function moveRight(){ if(targetLane<2) targetLane++; }
    function doJump(){ if(isJumping || isSliding) return; isJumping = true; verticalVel = JUMP_V; }
    function doSlide(){ if(isJumping || isSliding) return; isSliding = true; slideTimer = 0.9; }

    // touch/swipe
    let touchStartX = null; let touchStartY = null;
    window.addEventListener('touchstart', (e)=>{
      if(e.touches && e.touches.length>0){ touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; }
    });
    window.addEventListener('touchend', (e)=>{
      if(touchStartX==null) return;
      const dx = (e.changedTouches[0].clientX - touchStartX);
      const dy = (e.changedTouches[0].clientY - touchStartY);
      if(Math.abs(dx) > Math.abs(dy) && Math.abs(dx)>30){ if(dx>0) moveRight(); else moveLeft(); }
      else if(Math.abs(dy)>30){ if(dy < 0) doJump(); else doSlide(); }
      touchStartX = null; touchStartY = null;
    });

    // on-screen buttons for mobile
    const tcLeft = document.getElementById('tcLeft');
    const tcRight = document.getElementById('tcRight');
    tcLeft.addEventListener('touchstart', (e)=>{ e.preventDefault(); moveLeft(); });
    tcRight.addEventListener('touchstart', (e)=>{ e.preventDefault(); moveRight(); });

    // UI buttons
    document.getElementById('playBtn').addEventListener('click', ()=>{ restart(); document.getElementById('touchControls').style.display = (('ontouchstart' in window)?'flex':'none'); });
    document.getElementById('restartBtn').addEventListener('click', ()=> restart());
    document.getElementById('menuBtn').addEventListener('click', ()=>{ gameOverPanel.style.display='none'; startScreen.style.display='flex'; });
    document.getElementById('resetHighBtn').addEventListener('click', ()=>{ setHigh(0); refreshHighDisplays(); });

    // responsiveness
    window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); });

    // animate
    function animate(){
      requestAnimationFrame(animate);
      const t = performance.now()/1000;
      const dt = Math.min(0.05, t - lastTime);
      lastTime = t;

      // camera follows player subtly
      camera.position.x += (player.position.x - camera.position.x) * Math.min(1, 4*dt);
      camera.position.z = player.position.z + 4;
      camera.lookAt(player.position.x, player.position.y+0.8, player.position.z - 6);

      update(dt);
      renderer.render(scene, camera);
    }
    animate();

    // On load: show start screen with high score
    startScreen.style.display = 'flex';
    document.getElementById('startHigh').textContent = getHigh();

  })();
  </script>
</body>
</html>
